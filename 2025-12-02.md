# 2025-12-02 学习总结与明日计划

## 今日学习内容总结

### 1. 二叉树的存储方式（已掌握并实践）

#### 顺序存储（数组存储）
- **适用场景**：完全二叉树
- **索引计算规则**：
  - 父节点索引 = (子节点索引 - 1) / 2
  - 左孩子索引 = 2 * 父节点索引 + 1  
  - 右孩子索引 = 2 * 父节点索引 + 2
- **优点**：节省指针空间，内存连续访问效率高
- **缺点**：不适合非完全二叉树，插入删除复杂

**实践代码**：`/home/embedded-learning/2025-12-02/code/array_binary_tree.c`

#### 链式存储
- **适用场景**：所有二叉树类型
- **节点结构**：
```c
typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;
```
- **优点**：结构灵活，插入删除简单
- **缺点**：需要额外存储指针

**实践代码**：`/home/embedded-learning/2025-12-02/code/linked_binary_tree.c`

### 2. 三种深度优先遍历法（已掌握并实践）

#### 前序遍历（Pre-order）
- **访问顺序**：根 → 左 → 右
- **应用场景**：复制树结构、前缀表达式
- **递归实现**：
```c
void preOrder(TreeNode* root) {
    if (!root) return;
    printf("%d ", root->data);
    preOrder(root->left);
    preOrder(root->right);
}
```

#### 中序遍历（In-order）  
- **访问顺序**：左 → 根 → 右
- **应用场景**：二叉搜索树有序输出、中缀表达式
- **递归实现**：
```c
void inOrder(TreeNode* root) {
    if (!root) return;
    inOrder(root->left);
    printf("%d ", root->data);
    inOrder(root->right);
}
```

#### 后序遍历（Post-order）
- **访问顺序**：左 → 右 → 根
- **应用场景**：释放树内存、后缀表达式
- **递归实现**：
```c
void postOrder(TreeNode* root) {
    if (!root) return;
    postOrder(root->left);
    postOrder(root->right);
    printf("%d ", root->data);
}
```

**实践代码**：`/home/embedded-learning/2025-12-02/code/pre_tree.c`

## 明日学习计划

### 1. 编程练习（LeetCode题目）

#### 二叉树的最大深度（LeetCode 104）
**题目要求**：给定一个二叉树，找出其最大深度。

**解题思路**：
- 递归计算左右子树深度，取最大值+1
- 时间复杂度：O(n)，空间复杂度：O(h)

**代码框架**：
```c
int maxDepth(TreeNode* root) {
    if (!root) return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return (left > right ? left : right) + 1;
}
```

#### 二叉树的层序遍历（LeetCode 102）
**题目要求**：返回二叉树的层序遍历结果。

**解题思路**：
- 使用队列进行广度优先搜索
- 记录每层节点数量，按层输出

**代码框架**：
```c
void levelOrder(TreeNode* root) {
    if (!root) return;
    Queue* queue = createQueue();
    enqueue(queue, root);
    
    while (!isEmpty(queue)) {
        int size = getSize(queue);
        for (int i = 0; i < size; i++) {
            TreeNode* node = dequeue(queue);
            printf("%d ", node->val);
            if (node->left) enqueue(queue, node->left);
            if (node->right) enqueue(queue, node->right);
        }
    }
}
```

#### 根据前序和中序遍历序列构造二叉树（LeetCode 105）
**题目要求**：根据前序遍历和中序遍历的结果，重建二叉树。

**解题思路**：
- 前序遍历第一个元素是根节点
- 在中序遍历中找到根节点位置
- 递归构建左右子树

**代码框架**：
```c
TreeNode* buildTree(int* preorder, int preStart, int preEnd,
                   int* inorder, int inStart, int inEnd) {
    if (preStart > preEnd) return NULL;
    
    TreeNode* root = createNode(preorder[preStart]);
    int index = inStart;
    while (inorder[index] != root->val) index++;
    
    int leftSize = index - inStart;
    root->left = buildTree(preorder, preStart+1, preStart+leftSize,
                          inorder, inStart, index-1);
    root->right = buildTree(preorder, preStart+leftSize+1, preEnd,
                           inorder, index+1, inEnd);
    return root;
}
```

### 2. 二叉排序树与哈夫曼树

#### 二叉排序树（BST）
- **定义**：左子树所有节点值 < 根节点值 < 右子树所有节点值
- **操作**：插入、删除、查找
- **应用**：快速查找、排序

#### 哈夫曼树（Huffman Tree）
- **定义**：带权路径长度最短的二叉树
- **构建方法**：贪心算法，每次选择权值最小的两个节点合并
- **应用**：数据压缩、哈夫曼编码

### 3. 查找与排序算法学习

#### 查找算法
1. **顺序查找**：O(n)
2. **二分查找**：O(log n)，要求有序
3. **哈希查找**：O(1)，需要哈希函数

#### 排序算法
1. **冒泡排序**：O(n²)，稳定
2. **选择排序**：O(n²)，不稳定  
3. **插入排序**：O(n²)，稳定
4. **快速排序**：O(n log n)，不稳定
5. **归并排序**：O(n log n)，稳定
6. **堆排序**：O(n log n)，不稳定

## 学习资源

### 代码文件位置
- 今日实践代码：`/home/embedded-learning/2025-12-02/code/`
- 学习文档：`/home/embedded-learning/2025-12-02/树与二叉树(2).md`
- 面试题准备：`/home/embedded-learning/2025-12-02/二叉树高频面试题.md`

### 在线资源
- LeetCode题库：https://leetcode.com/
- 数据结构可视化：https://visualgo.net/
- 算法动画演示：https://algorithm-visualizer.org/

## 学习建议

### 今日重点回顾
1. 理解两种存储方式的适用场景和优缺点
2. 掌握三种遍历方法的递归和非递归实现
3. 熟练编写二叉树的基本操作代码

### 明日学习重点
1. 先完成LeetCode题目，巩固二叉树操作
2. 理解二叉排序树和哈夫曼树的构建原理
3. 对比不同查找排序算法的性能特点

### 实践建议
- 每个算法都要手动实现一遍
- 理解时间复杂度和空间复杂度
- 多做题目，培养算法思维

---

**明日目标**：完成3道LeetCode题目，掌握二叉排序树和哈夫曼树，开始学习查找排序算法。