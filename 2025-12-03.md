# 2025-12-03 学习计划

## 今日学习目标

### 1. 编程练习（LeetCode题目）

#### 二叉树的最大深度（LeetCode 104）
**题目描述**：给定一个二叉树，找出其最大深度。

**解题思路**：
- 使用递归方法，计算左右子树的最大深度
- 最大深度 = max(左子树深度, 右子树深度) + 1
- 时间复杂度：O(n)，空间复杂度：O(h)

**代码实现**：
```c
int maxDepth(TreeNode* root) {
    if (root == NULL) return 0;
    int leftDepth = maxDepth(root->left);
    int rightDepth = maxDepth(root->right);
    return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
}
```

**测试用例**：
输入：[3,9,20,null,null,15,7] 输出：3

输入：[1,null,2] 输出：2


#### 二叉树的层序遍历（LeetCode 102）
**题目描述**：给你二叉树的根节点 root，返回其节点值的层序遍历。

**解题思路**：
- 使用队列进行广度优先搜索
- 记录每层的节点数量，按层输出
- 时间复杂度：O(n)，空间复杂度：O(n)

**代码实现**：
```c
int** levelOrder(TreeNode* root, int* returnSize, int** returnColumnSizes) {
    if (root == NULL) {
        *returnSize = 0;
        return NULL;
    }
    
    // 使用队列进行BFS
    TreeNode** queue = (TreeNode**)malloc(1000 * sizeof(TreeNode*));
    int front = 0, rear = 0;
    queue[rear++] = root;
    
    int** result = (int**)malloc(1000 * sizeof(int*));
    *returnColumnSizes = (int*)malloc(1000 * sizeof(int));
    *returnSize = 0;
    
    while (front < rear) {
        int levelSize = rear - front;
        int* level = (int*)malloc(levelSize * sizeof(int));
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = queue[front++];
            level[i] = node->val;
            
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
        }
        
        result[*returnSize] = level;
        (*returnColumnSizes)[*returnSize] = levelSize;
        (*returnSize)++;
    }
    
    free(queue);
    return result;
}
```

**测试用例**：
```
输入：[3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]]

输入：[1] 输出：[[1]]
```



#### 根据前序和中序遍历序列构造二叉树（LeetCode 105）
**题目描述**：给定两个整数数组 preorder 和 inorder，其中 preorder 是二叉树的前序遍历，inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

**解题思路**：
- 前序遍历的第一个元素是根节点
- 在中序遍历中找到根节点的位置
- 递归构建左子树和右子树
- 时间复杂度：O(n)，空间复杂度：O(n)

**代码实现**：
```c
TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {
    return buildTreeHelper(preorder, 0, preorderSize-1, inorder, 0, inorderSize-1);
}

TreeNode* buildTreeHelper(int* preorder, int preStart, int preEnd, 
                         int* inorder, int inStart, int inEnd) {
    if (preStart > preEnd || inStart > inEnd) return NULL;
    
    // 前序遍历的第一个元素是根节点
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->val = preorder[preStart];
    
    // 在中序遍历中找到根节点的位置
    int rootIndex = inStart;
    while (inorder[rootIndex] != root->val) rootIndex++;
    
    // 计算左子树的大小
    int leftSize = rootIndex - inStart;
    
    // 递归构建左右子树
    root->left = buildTreeHelper(preorder, preStart+1, preStart+leftSize,
                                inorder, inStart, rootIndex-1);
    root->right = buildTreeHelper(preorder, preStart+leftSize+1, preEnd,
                                 inorder, rootIndex+1, inEnd);
    
    return root;
}
```

**测试用例**：
```
输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出：[3,9,20,null,null,15,7]
```



### 2. 二叉排序树与哈夫曼树掌握和实践

#### 二叉排序树（Binary Search Tree, BST）
**定义**：对于树中的每个节点，其左子树的所有节点值都小于该节点的值，其右子树的所有节点值都大于该节点的值。

**基本操作**：
1. **插入操作**：
```c
TreeNode* insertBST(TreeNode* root, int val) {
    if (root == NULL) {
        TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
        newNode->val = val;
        newNode->left = newNode->right = NULL;
        return newNode;
    }
    
    if (val < root->val) {
        root->left = insertBST(root->left, val);
    } else {
        root->right = insertBST(root->right, val);
    }
    return root;
}
```

2. **查找操作**：
```c
TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL || root->val == val) return root;
    
    if (val < root->val) {
        return searchBST(root->left, val);
    } else {
        return searchBST(root->right, val);
    }
}
```

3. **删除操作**：
```c
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == NULL) return NULL;
    
    if (key < root->val) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->val) {
        root->right = deleteNode(root->right, key);
    } else {
        // 找到要删除的节点
        if (root->left == NULL) {
            TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            TreeNode* temp = root->left;
            free(root);
            return temp;
        } else {
            // 有两个子节点，找到右子树的最小节点
            TreeNode* temp = findMin(root->right);
            root->val = temp->val;
            root->right = deleteNode(root->right, temp->val);
        }
    }
    return root;
}
```

#### 哈夫曼树（Huffman Tree）
**定义**：带权路径长度最短的二叉树，用于数据压缩。

**构建步骤**：
1. 将所有权值作为单独的树
2. 每次选择权值最小的两棵树合并
3. 新树的权值为两棵树权值之和
4. 重复直到只剩一棵树

**代码实现**：
```c
typedef struct HuffmanNode {
    char data;
    int freq;
    struct HuffmanNode *left, *right;
} HuffmanNode;

// 构建哈夫曼树
HuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {
    // 创建最小堆，按频率排序
    // 每次取出两个最小频率的节点，合并
    // 重复直到堆中只剩一个节点
    // 返回根节点
}
```

### 3. 查找与排序算法学习

#### 查找算法
1. **顺序查找**：O(n)
```c
int sequentialSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) return i;
    }
    return -1;
}
```

2. **二分查找**：O(log n)，要求有序
```c
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

#### 排序算法
1. **冒泡排序**：O(n²)
```c
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

2. **快速排序**：O(n log n)
```c
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    int temp = arr[i+1];
    arr[i+1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
```

## 学习时间安排

### 上午（9:00-12:00）
- **9:00-10:30**：完成LeetCode 104、102题目
- **10:30-12:00**：完成LeetCode 105题目

### 下午（14:00-18:00）
- **14:00-15:30**：学习二叉排序树，实现基本操作
- **15:30-17:00**：学习哈夫曼树，理解构建原理
- **17:00-18:00**：开始学习查找算法

### 晚上（19:00-21:00）
- **19:00-20:30**：学习排序算法，实现冒泡排序和快速排序
- **20:30-21:00**：复习今日内容，整理笔记

## 实践要求

### 代码实现要求
1. 每个算法都要手动实现，理解原理
2. 添加详细的注释说明
3. 编写测试用例验证正确性
4. 分析时间复杂度和空间复杂度

### 学习成果检验
1. 能够独立完成3道LeetCode题目
2. 能够实现二叉排序树的基本操作
3. 理解哈夫曼树的构建过程
4. 掌握至少2种查找和2种排序算法

## 学习资源

### 代码文件位置
- 今日代码：`/home/embedded-learning/2025-12-03/code/`
- 参考文档：`/home/embedded-learning/2025-12-02/树与二叉树(2).md`

### 在线资源
- LeetCode题库：https://leetcode.com/
- 算法可视化：https://visualgo.net/
- 数据结构教程：https://www.geeksforgeeks.org/

---

**今日目标**：完成3道LeetCode题目，掌握二叉排序树和哈夫曼树，开始学习查找排序算法。