# 2025年12月5日学习记录：完整的IO编程体系

## 学习目标：掌握Linux系统编程中的完整IO体系

### 今日学习重点
- 文件系统IO（底层IO）
- 标准IO（高级IO）
- 两种IO方式的对比与选择
- 实际项目应用

## 一、文件系统IO（系统调用IO）

### 1.1 核心函数列表

#### 文件操作函数
```c
int open(const char *pathname, int flags, mode_t mode);  // 打开文件
int close(int fd);                                       // 关闭文件
int creat(const char *pathname, mode_t mode);           // 创建文件
```

#### 数据读写函数
```c
ssize_t read(int fd, void *buf, size_t count);          // 读取数据
ssize_t write(int fd, const void *buf, size_t count);   // 写入数据
```

#### 文件定位函数
```c
off_t lseek(int fd, off_t offset, int whence);          // 文件定位
```

#### 内存映射函数
```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);                  // 取消内存映射
```

### 1.2 文件打开标志（flags）

**常用标志组合：**
- `O_RDONLY` - 只读
- `O_WRONLY` - 只写  
- `O_RDWR` - 读写
- `O_CREAT` - 文件不存在时创建
- `O_TRUNC` - 清空文件
- `O_APPEND` - 追加模式

### 1.3 文件系统IO示例

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    // 打开文件（系统IO方式）
    int fd = open("test.txt", O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        perror("open failed");
        return -1;
    }
    
    // 写入数据
    char *data = "Hello, System IO!";
    ssize_t written = write(fd, data, strlen(data));
    
    // 定位到文件开头
    lseek(fd, 0, SEEK_SET);
    
    // 读取数据
    char buffer[100];
    ssize_t read_bytes = read(fd, buffer, sizeof(buffer)-1);
    buffer[read_bytes] = '\0';
    
    printf("读取的内容: %s\n", buffer);
    
    // 关闭文件
    close(fd);
    return 0;
}
```

## 二、标准IO（流式IO）

### 2.1 核心函数分类

#### 文件操作
```c
FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *stream);
```

#### 字符IO
```c
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
int getchar(void);
int putchar(int c);
```

#### 字符串IO
```c
char *fgets(char *str, int n, FILE *stream);
int fputs(const char *str, FILE *stream);
```

#### 格式化IO
```c
int fprintf(FILE *stream, const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
```

#### 二进制IO
```c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
```

#### 文件定位
```c
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
```

### 2.2 标准IO示例

```c
#include <stdio.h>

int main() {
    // 打开文件（标准IO方式）
    FILE *fp = fopen("test.txt", "w+");
    if (!fp) {
        perror("fopen failed");
        return -1;
    }
    
    // 格式化写入
    fprintf(fp, "姓名: %s, 年龄: %d\n", "张三", 25);
    
    // 重新定位到文件开头
    rewind(fp);
    
    // 逐行读取
    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        printf("读取的行: %s", line);
    }
    
    fclose(fp);
    return 0;
}
```

## 三、两种IO方式的对比

### 3.1 性能对比

| 特性 | 文件系统IO | 标准IO |
|------|------------|--------|
| 性能 | 较高（无缓冲） | 较低（有缓冲） |
| 缓冲 | 无缓冲 | 全缓冲/行缓冲/无缓冲 |
| 易用性 | 较低 | 较高 |
| 可移植性 | 较低（系统相关） | 较高（标准C） |
| 功能 | 基础功能 | 丰富功能 |

### 3.2 适用场景

**使用文件系统IO的场景：**
- 需要最高性能的场合
- 设备文件操作
- 需要精细控制文件描述符
- 实现底层系统工具

**使用标准IO的场景：**
- 文本文件处理
- 需要格式化输入输出
- 跨平台开发
- 快速开发应用

## 四、混合使用示例

### 4.1 文件描述符与文件指针转换

```c
#include <stdio.h>
#include <fcntl.h>

int main() {
    // 使用系统IO打开文件
    int fd = open("mixed.txt", O_RDWR | O_CREAT, 0644);
    
    // 将文件描述符转换为文件指针
    FILE *fp = fdopen(fd, "w+");
    
    // 使用标准IO操作
    fprintf(fp, "混合IO操作示例\n");
    fflush(fp);  // 确保数据写入
    
    // 可以继续使用系统IO
    lseek(fd, 0, SEEK_SET);
    
    // 关闭时注意：关闭文件指针会自动关闭文件描述符
    fclose(fp);
    
    return 0;
}
```

## 五、实际项目应用

### 5.1 文件复制工具（系统IO实现）

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int copy_file_sysio(const char *src, const char *dst) {
    int src_fd = open(src, O_RDONLY);
    if (src_fd == -1) return -1;
    
    int dst_fd = open(dst, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dst_fd == -1) {
        close(src_fd);
        return -1;
    }
    
    char buffer[4096];
    ssize_t bytes_read;
    
    while ((bytes_read = read(src_fd, buffer, sizeof(buffer))) > 0) {
        if (write(dst_fd, buffer, bytes_read) != bytes_read) {
            close(src_fd);
            close(dst_fd);
            return -1;
        }
    }
    
    close(src_fd);
    close(dst_fd);
    return 0;
}
```

### 5.2 日志分析工具（标准IO实现）

```c
#include <stdio.h>
#include <string.h>

void analyze_log_file(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) return;
    
    char line[1024];
    int error_count = 0, warning_count = 0, info_count = 0;
    
    while (fgets(line, sizeof(line), fp)) {
        if (strstr(line, "ERROR")) error_count++;
        else if (strstr(line, "WARNING")) warning_count++;
        else if (strstr(line, "INFO")) info_count++;
    }
    
    printf("日志分析结果:\n");
    printf("错误: %d\n", error_count);
    printf("警告: %d\n", warning_count);
    printf("信息: %d\n", info_count);
    
    fclose(fp);
}
```

## 六、高级主题

### 6.1 非阻塞IO
```c
// 设置文件描述符为非阻塞模式
int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);
```

### 6.2 异步IO
```c
#include <aio.h>
struct aiocb aio_req;
// 配置异步IO请求
aio_read(&aio_req);
```

### 6.3 内存映射文件
```c
void *map = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, fd, 0);
// 直接操作内存映射区域
munmap(map, file_size);
```

## 七、最佳实践

### 7.1 错误处理
```c
// 系统IO错误处理
if (fd == -1) {
    perror("open failed");
    return -1;
}

// 标准IO错误处理
if (ferror(fp)) {
    perror("文件操作错误");
    clearerr(fp);
}
```

### 7.2 资源管理
- 确保每个`open()`都有对应的`close()`
- 确保每个`fopen()`都有对应的`fclose()`
- 使用`RAII`模式管理资源

### 7.3 性能优化
- 选择合适的缓冲区大小
- 批量读写减少系统调用
- 使用内存映射处理大文件

## 八、学习总结

### 掌握要点
- ✅ 文件系统IO的所有核心函数
- ✅ 标准IO的完整函数体系
- ✅ 两种IO方式的对比与选择
- ✅ 实际项目中的应用场景
- ✅ 错误处理和性能优化

### 实践建议
1. 编写文件操作工具（复制、分割、合并）
2. 实现日志系统
3. 开发配置文件解析器
4. 创建数据备份工具

### 下一步学习
1. 进程间通信（管道、消息队列）
2. 网络编程（Socket）
3. 多线程编程
4. 数据库操作

---

**今日收获：** 全面掌握了Linux系统编程中的IO体系，能够根据具体需求选择合适的IO方式，并能够编写高效、可靠的文件操作程序。