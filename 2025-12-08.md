# 2025-12-08 学习笔记 - Linux进程管理与exec函数族

## 📚 今日学习内容

### 1. 进程等待与回收

#### 1.1 wait()函数
- **功能**：阻塞等待任意子进程退出
- **返回值**：成功返回子进程PID，失败返回-1
- **状态解析**：
  - `WIFEXITED(status)`：判断是否正常退出
  - `WEXITSTATUS(status)`：获取退出码
  - `WIFSIGNALED(status)`：判断是否被信号终止
  - `WTERMSIG(status)`：获取终止信号编号

**代码示例**：<mcfile name="wait_demo.c" path="/home/embedded-learning/2025-12-08/code/wait_demo.c"></mcfile>
```c
pid_t ret = wait(&status); // 阻塞等待子进程退出
if(WIFEXITED(status)){
    printf("子进程正常退出，退出码：%d\n", WEXITSTATUS(status));
}else if(WIFSIGNALED(status)){
    printf("子进程被信号%d终止\n", WTERMSIG(status));
}
```

#### 1.2 waitpid()函数
- **功能**：更灵活的进程等待
- **参数**：
  - `pid`：指定等待的进程ID（-1表示任意子进程）
  - `status`：存储退出状态
  - `options`：选项（WNOHANG非阻塞）

**非阻塞等待**：<mcfile name="waitpid_nonblock.c" path="/home/embedded-learning/2025-12-08/code/waitpid_nonblock.c"></mcfile>
```c
// 非阻塞方式等待子进程
pid_t ret = waitpid(-1, &status, WNOHANG);
if(ret == 0){
    printf("子进程尚未退出\n");
}
```

**等待所有子进程**：<mcfile name="waitpid_all.c" path="/home/embedded-learning/2025-12-08/code/waitpid_all.c"></mcfile>
```c
// 循环回收所有子进程
while(count < 3){
    pid_t ret = waitpid(-1, &status, WNOHANG);
    if(ret > 0){
        count++;
        printf("子进程(pid:%d)被回收\n", ret);
    }
}
```

### 2. 僵尸进程与孤儿进程

#### 2.1 僵尸进程 (Zombie Process)
- **定义**：子进程退出但父进程未回收
- **危害**：占用系统资源（进程表项）
- **观察方法**：`ps aux | grep Z`

**僵尸进程示例**：<mcfile name="zombie.c" path="/home/embedded-learning/2025-12-08/code/zombie.c"></mcfile>
```c
// 子进程退出，父进程不回收
if(pid == 0){ // 子进程
    printf("子进程PID:%d,即将退出\n", getpid());
    exit(0); // 成为僵尸进程
}else{ // 父进程
    sleep(30); // 不回收子进程
}
```

#### 2.2 孤儿进程 (Orphan Process)
- **定义**：父进程先于子进程退出
- **处理**：被init进程(PID=1)接管
- **特点**：不会成为僵尸进程

### 3. exec函数族

#### 3.1 execl()函数
- **功能**：执行新程序，替换当前进程映像
- **参数**：路径 + 参数列表 + NULL结尾

**execl示例**：<mcfile name="execl_demo.c" path="/home/embedded-learning/2025-12-08/code/execl_demo.c"></mcfile>
```c
execl("/bin/ls", "ls", "-l", NULL); // 执行ls -l命令
```

#### 3.2 execlp()函数
- **功能**：在PATH环境变量中查找程序
- **特点**：不需要完整路径

**execlp示例**：<mcfile name="execlp_demo.c" path="/home/embedded-learning/2025-12-08/code/execlp_demo.c"></mcfile>
```c
execlp("ls", "ls", "-l", NULL); // 自动在PATH中查找ls
```

#### 3.3 execvp()函数
- **功能**：使用参数数组执行程序
- **特点**：适合动态参数

**execvp示例**：<mcfile name="execvp.c" path="/home/embedded-learning/2025-12-08/code/execvp.c"></mcfile>
```c
char *args[] = {"ls", "-l", "-a", NULL};
execvp("ls", args); // 使用参数数组
```

### 4. system()函数

#### 4.1 system()基本使用
- **功能**：执行shell命令
- **返回值**：命令执行状态

**system示例**：<mcfile name="system_demo.c" path="/home/embedded-learning/2025-12-08/code/system_demo.c"></mcfile>
```c
int ret = system("ls -l"); // 执行shell命令
printf("命令返回值：%d\n", ret);
```

#### 4.2 自定义system实现
- **原理**：fork() + exec() + wait()
- **实现**：模拟system函数功能

**自定义system**：<mcfile name="my_system.c" path="/home/embedded-learning/2025-12-08/code/my_system.c"></mcfile>
```c
// 自定义system函数实现
int my_system(const char *cmd){
    pid_t pid = fork();
    if(pid == 0){
        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(127); // exec失败
    }
    int status;
    waitpid(pid, &status, 0);
    return status;
}
```

### 5. 多进程管理

#### 5.1 等待多个子进程
- **策略**：循环调用wait()或waitpid()
- **问题**：需要知道子进程数量

**多进程等待**：<mcfile name="wait_multi.c" path="/home/embedded-learning/2025-12-08/code/wait_multi.c"></mcfile>

#### 5.2 错误状态处理
- **场景**：处理wait()失败的情况
- **错误类型**：无子进程、信号中断等

**错误处理**：<mcfile name="wait_status_error.c" path="/home/embedded-learning/2025-12-08/code/wait_status_error.c"></mcfile>

## 🔧 关键知识点

### 进程状态转换
    运行中 → 退出 → 僵尸进程 → 被回收 
    运行中 → 孤儿进程 → 被init接管

### exec函数族比较
| 函数 | 路径查找 | 参数传递 | 环境变量 |
|------|----------|----------|----------|
| execl | 需要完整路径 | 参数列表 | 继承当前 |
| execlp | PATH环境变量 | 参数列表 | 继承当前 |
| execvp | PATH环境变量 | 参数数组 | 继承当前 |

### 进程回收策略
1. **阻塞等待**：`wait()` - 简单但效率低
2. **非阻塞等待**：`waitpid(..., WNOHANG)` - 高效但复杂
3. **信号驱动**：最佳实践（后续学习）

## 💡 实践总结

### wait()与waitpid()对比
- **wait()**：简单易用，适合单个子进程
- **waitpid()**：功能强大，支持非阻塞和指定进程

### exec函数族使用场景
- **execl()**：已知完整路径的固定参数程序
- **execlp()**：系统命令或PATH中的程序
- **execvp()**：动态参数或脚本执行

### 僵尸进程处理
- **重要性**：必须回收避免资源泄漏
- **方法**：父进程调用wait()系列函数
- **最佳实践**：信号SIGCHLD驱动回收

## 🚀 下一步学习建议

1. **信号处理**：SIGCHLD信号自动回收子进程
2. **进程间通信**：管道、消息队列、共享内存
3. **守护进程**：后台运行的特殊进程
4. **线程编程**：轻量级并发处理

## 📝 完整代码文件列表

- `wait_demo.c` - wait()函数基本使用
- `waitpid_all.c` - 回收所有子进程
- `waitpid_nonblock.c` - 非阻塞等待
- `waitpid_specify.c` - 指定进程等待
- `wait_multi.c` - 多进程等待管理
- `wait_no_child.c` - 无子进程错误处理
- `wait_status_error.c` - 状态错误处理
- `zombie.c` - 僵尸进程演示
- `execl_demo.c` - execl函数使用
- `execlp_demo.c` - execlp函数使用
- `execvp.c` - execvp函数使用
- `system_demo.c` - system函数使用
- `system_ret.c` - system返回值处理
- `my_system.c` - 自定义system实现

---

*学习时间：2025年12月8日*
*学习重点：Linux进程管理、exec函数族、进程回收机制*