# 2025-12-09 学习笔记 - Linux进程管理与信号处理

## 📚 今日学习内容

### 1. 孤儿进程 (Orphan Process)
- **概念**：父进程先于子进程退出，子进程成为孤儿进程
- **特点**：
  - 被init进程(PID=1)接管
  - 脱离原父进程的终端关联
  - 稳定性更高（不会因为终端关闭而退出）

**代码示例**：<mcfile name="orphan.c" path="/home/embedded-learning/2025-12-09/code/orphan.c"></mcfile>
```c
// 制造孤儿进程
pid_t pid = fork();
if(pid == 0){ // 子进程
    printf("子进程PID:%d,当前父进程PID:%d\n",getpid(),getppid());
    sleep(10); // 让父进程先退出
    printf("子进程PID:%d,当前父进程PID:%d\n",getpid(),getppid()); // 父进程变为init
}
```

### 2. 守护进程 (Daemon Process)
- **定义**：在后台运行的特殊进程，脱离终端控制
- **创建步骤**：
  1. `fork()`创建子进程，父进程退出
  2. `setsid()`创建新会话（脱离终端）
  3. `chdir("/")`切换工作目录到根目录
  4. `umask(0)`重置文件权限掩码
  5. 关闭所有无关文件描述符

**简易守护进程**：<mcfile name="daemon_step.c" path="/home/embedded-learning/2025-12-09/code/daemon_step.c"></mcfile>
**完整守护进程**：<mcfile name="full_daemon.c" path="/home/embedded-learning/2025-12-09/code/full_daemon.c"></mcfile>

### 3. 进程与线程性能对比
- **进程创建开销**：较大，需要复制父进程资源
- **线程创建开销**：较小，共享进程资源
- **性能测试**：创建1000个进程 vs 1000个线程

**性能对比代码**：<mcfile name="proc_vs_thread.c" path="/home/embedded-learning/2025-12-09/code/proc_vs_thread.c"></mcfile>
```c
// 测试创建1000个进程的耗时
for (int i = 0; i < 1000; i++) {
    pid_t pid = fork();
    if(pid == 0) {exit(0);}
    wait(NULL);
}

// 测试创建1000个线程的耗时
pthread_t tid;
for(int i = 0; i < 1000; i++) {
    pthread_create(&tid, NULL, thread_func, NULL);
    pthread_join(tid, NULL);
}
```

### 4. 信号处理 (Signal Handling)

#### 4.1 基础信号
- **SIGINT(2)**：Ctrl+C，默认终止进程
- **SIGTERM(15)**：kill命令默认信号，优雅终止
- **SIGKILL(9)**：强制终止，不可捕获
- **SIGUSR1(10)**：用户自定义信号1

**信号基础示例**：<mcfile name="signal_basic.c" path="/home/embedded-learning/2025-12-09/code/signal_basic.c"></mcfile>

#### 4.2 sigaction高级信号处理
- **优点**：比signal()更强大、更安全
- **特性**：
  - 信号处理期间可以阻塞其他信号
  - 支持自动重启被中断的系统调用
  - 提供更详细的信号信息

**基础sigaction示例**：<mcfile name="sigaction_demo1.c" path="/home/embedded-learning/2025-12-09/code/sigaction_demo1.c"></mcfile>
```c
struct sigaction sa;
sa.sa_handler = sigint_handler; // 自定义处理函数
sigemptyset(&sa.sa_mask);       // 不阻塞其他信号
sa.sa_flags = SA_RESTART;       // 重启被中断的系统调用
sigaction(SIGINT, &sa, NULL);   // 注册信号处理
```

**信号阻塞示例**：<mcfile name="sigaction_demo2.c" path="/home/embedded-learning/2025-12-09/code/sigaction_demo2.c"></mcfile>
```c
// 处理SIGUSR1时阻塞SIGINT
sigaddset(&sa.sa_mask, SIGINT); // 在处理SIGUSR1期间阻塞SIGINT
```

#### 4.3 信号集操作 (Signal Set)
- `sigset_t`：信号集数据类型
- 操作函数：
  - `sigemptyset()`：清空信号集
  - `sigfillset()`：填充所有信号
  - `sigaddset()`：添加信号到集合
  - `sigdelset()`：从集合删除信号
  - `sigismember()`：检查信号是否在集合中

**信号集操作**：<mcfile name="sigset_demo.c" path="/home/embedded-learning/2025-12-09/code/sigset_demo.c"></mcfile>

#### 4.4 信号阻塞与解除
- `sigprocmask()`：修改进程信号掩码
- 参数：
  - `SIG_BLOCK`：添加到阻塞集
  - `SIG_UNBLOCK`：从阻塞集移除
  - `SIG_SETMASK`：设置新的阻塞集

**重要发现**：信号阻塞只是延迟递送，解除阻塞时挂起的信号会立即递送！

## 🔧 关键知识点

### 进程关系管理
```bash
# 查看进程树关系
ps -ef | grep -E "PID|daemon"
pstree -p

# 查看进程的会话ID和进程组ID
ps -eo pid,ppid,pgid,sid,comm
```

### 守护进程日志问题
- **问题**：日志文件创建在根目录而非当前目录
- **原因**：`chdir("/")`切换工作目录到根目录
- **解决方案**：使用绝对路径或修改工作目录

### 信号处理注意事项
1. **信号阻塞不丢弃信号**，只是延迟递送
2. **解除阻塞时**，挂起的信号会立即递送
3. **安全处理**：先检查挂起信号，再解除阻塞
4. **信号处理函数**：应尽量简单，避免复杂操作

## 💡 实践总结

### 孤儿进程实践
- 理解了进程父子关系的重要性
- 掌握了孤儿进程的创建和观察方法
- 学会了使用`ps`命令监控进程状态

### 守护进程开发
- 掌握了守护进程的标准创建流程
- 理解了守护进程脱离终端控制的原理
- 解决了日志文件路径问题

### 进程与线程性能
- 验证了线程创建开销远小于进程创建
- 理解了进程和线程的资源管理差异
- 掌握了性能测试的基本方法

### 信号处理进阶
- 熟练使用信号集操作函数
- 掌握了sigaction的高级特性
- 理解了信号阻塞与解除的机制
- 学会了安全处理挂起信号的方法

## 🚀 下一步学习建议

1. **多进程通信**：管道、消息队列、共享内存
2. **线程同步**：互斥锁、条件变量、信号量
3. **高级信号处理**：实时信号、信号队列
4. **进程间同步**：文件锁、信号量

## 📝 完整代码文件列表

- `orphan.c` - 孤儿进程演示
- `daemon_step.c` - 简易守护进程框架
- `full_daemon.c` - 完整守护进程实现
- `proc_vs_thread.c` - 进程与线程性能对比
- `signal_basic.c` - 基础信号处理
- `sigaction_demo1.c` - 基础sigaction使用
- `sigaction_demo2.c` - 信号阻塞处理
- `sigset_demo.c` - 信号集操作演示
- `daemon_demo.log` - 守护进程日志文件

---

*学习时间：2025年12月9日*
*学习重点：Linux进程管理、信号处理机制、进程与线程性能对比*