# 二叉树高频面试题与答案

## 基础概念题

### 1. 二叉树与二叉搜索树的区别？
**答案：**
- **二叉树**：每个节点最多有两个子节点，没有排序规则
- **二叉搜索树**：左子树所有节点值 < 根节点值 < 右子树所有节点值

### 2. 完全二叉树与满二叉树的区别？
**答案：**
- **满二叉树**：所有层都完全填满，节点数=2^h-1
- **完全二叉树**：除最后一层外完全填满，最后一层从左到右填充

### 3. 二叉树有哪些遍历方式？
**答案：**
- 前序遍历：根→左→右
- 中序遍历：左→根→右  
- 后序遍历：左→右→根
- 层次遍历：按层遍历

## 算法实现题

### 4. 实现二叉树的前中后序遍历（递归+非递归）
```c
// 递归前序遍历
void preOrder(TreeNode* root) {
    if (!root) return;
    printf("%d ", root->val);
    preOrder(root->left);
    preOrder(root->right);
}

// 非递归前序遍历（使用栈）
void preOrderIterative(TreeNode* root) {
    if (!root) return;
    Stack* stack = createStack();
    push(stack, root);
    
    while (!isEmpty(stack)) {
        TreeNode* node = pop(stack);
        printf("%d ", node->val);
        if (node->right) push(stack, node->right);
        if (node->left) push(stack, node->left);
    }
}
```

### 5. 求二叉树的最大深度
```c
int maxDepth(TreeNode* root) {
    if (!root) return 0;
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    return (left > right ? left : right) + 1;
}
```

### 6. 判断二叉树是否对称
```c
bool isSymmetric(TreeNode* root) {
    if (!root) return true;
    return isMirror(root->left, root->right);
}

bool isMirror(TreeNode* left, TreeNode* right) {
    if (!left && !right) return true;
    if (!left || !right) return false;
    return (left->val == right->val) && 
           isMirror(left->left, right->right) && 
           isMirror(left->right, right->left);
}
```

### 7. 二叉树的层次遍历
```c
void levelOrder(TreeNode* root) {
    if (!root) return;
    Queue* queue = createQueue();
    enqueue(queue, root);
    
    while (!isEmpty(queue)) {
        int size = getSize(queue);
        for (int i = 0; i < size; i++) {
            TreeNode* node = dequeue(queue);
            printf("%d ", node->val);
            if (node->left) enqueue(queue, node->left);
            if (node->right) enqueue(queue, node->right);
        }
        printf("\n");
    }
}
```

## 二叉搜索树相关

### 8. 验证二叉搜索树
```c
bool isValidBST(TreeNode* root) {
    return isValid(root, LONG_MIN, LONG_MAX);
}

bool isValid(TreeNode* root, long min, long max) {
    if (!root) return true;
    if (root->val <= min || root->val >= max) return false;
    return isValid(root->left, min, root->val) && 
           isValid(root->right, root->val, max);
}
```

### 9. 二叉搜索树中第K小的元素
```c
int kthSmallest(TreeNode* root, int k) {
    Stack* stack = createStack();
    TreeNode* curr = root;
    int count = 0;
    
    while (curr || !isEmpty(stack)) {
        while (curr) {
            push(stack, curr);
            curr = curr->left;
        }
        curr = pop(stack);
        if (++count == k) return curr->val;
        curr = curr->right;
    }
    return -1;
}
```

## 高级算法题

### 10. 二叉树的最近公共祖先
```c
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root == p || root == q) return root;
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    if (left && right) return root;
    return left ? left : right;
}
```

### 11. 从前序与中序遍历序列构造二叉树
```c
TreeNode* buildTree(int* preorder, int preStart, int preEnd, 
                   int* inorder, int inStart, int inEnd) {
    if (preStart > preEnd) return NULL;
    
    TreeNode* root = createNode(preorder[preStart]);
    int index = inStart;
    while (inorder[index] != root->val) index++;
    
    int leftSize = index - inStart;
    root->left = buildTree(preorder, preStart+1, preStart+leftSize,
                          inorder, inStart, index-1);
    root->right = buildTree(preorder, preStart+leftSize+1, preEnd,
                           inorder, index+1, inEnd);
    return root;
}
```

### 12. 二叉树的最大路径和
```c
int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    maxPathDown(root, &maxSum);
    return maxSum;
}

int maxPathDown(TreeNode* node, int* maxSum) {
    if (!node) return 0;
    int left = fmax(0, maxPathDown(node->left, maxSum));
    int right = fmax(0, maxPathDown(node->right, maxSum));
    *maxSum = fmax(*maxSum, left + right + node->val);
    return fmax(left, right) + node->val;
}
```

## 实际应用场景题

### 13. 堆（完全二叉树）的应用场景？
**答案：**
- 优先队列实现
- 堆排序算法
- 任务调度系统
- 图算法中的Dijkstra算法

### 14. 哈夫曼树（满二叉树）的应用？
**答案：**
- 数据压缩（哈夫曼编码）
- 文件压缩算法
- 通信编码优化

## 复杂度分析

### 15. 各种操作的时间复杂度？
- 插入/删除/查找（平衡BST）：O(log n)
- 遍历：O(n)
- 空间复杂度（递归）：O(h)，h为树高

## 实战技巧

### 面试准备建议：
1. **熟练掌握递归思想**：二叉树问题大多可用递归解决
2. **理解遍历顺序**：前中后序遍历的应用场景
3. **掌握非递归实现**：栈和队列的应用
4. **边界条件处理**：空树、单节点等特殊情况
5. **复杂度分析**：时间和空间复杂度分析

### 常见错误：
- 忘记处理空指针
- 递归终止条件错误
- 遍历顺序混淆
- 内存泄漏（C语言）