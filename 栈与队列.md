#   栈和队列

**学习日期：** 2025年11月27日  
**学习目标：** 掌握栈和队列的基本概念、实现方法和应用场景

## 3.1 栈和队列的定义和特点

### 3.1.1 栈的定义和特点
- **定义：** 
  - 栈（stack）仅限在栈顶（表尾）进行插入删除的线性表
- **特点：**
  - 后进先出（LIFO）
  - 插入、删除只能从队尾开始
- **应用：**
  - 迷宫问题、表达式求值、数制转换、函数调用、八皇后问题、递归调用的实现、行编辑程序、括号匹配的检验

### 3.1.2 队列的定义和特点
- **定义：**
  - 队列（queue）是一种先进先出的线性表，在表尾插入，在表头删除（头删尾插）
- **特点：**
  - 先进先出（FIFO）
  - 只能在队尾插入，只能在队头删除
- **应用：**
  - 脱机打印输出，按申请的先后顺序依次输出
  - 多用户系统中，多个用户排成队，分时地循环使用cpu
  - 实时控制系统中，信号按接收的先后顺序依次处理


## 3.2 案例引入
- **栈的应用案例：**
  - 表达式求值：在计算器中计算数学表达式的值
  - 函数调用：程序执行过程中函数调用的管理
  - 括号匹配：检查代码中括号是否正确匹配
  - 数制转换：将十进制数转换为其他进制数
  - 浏览器历史记录：后退功能的实现
- **队列的应用案例：**
  - 银行排队系统：客户按到达顺序接受服务
  - 打印机任务队列：打印任务按提交顺序处理
  - CPU任务调度：操作系统按优先级调度进程
  - 广度优先搜索：图遍历时按层次访问节点
  - 缓冲区管理：数据流的临时存储和处理


## 3.3 栈的表示和操作的实现
### ADT栈
**ADT Stack {**
- **数据对象：** D = {aᵢ | aᵢ ∈ ElemSet, i = 1,2,...,n, n ≥ 0}
- **数据关系：** R = {<aᵢ₋₁, aᵢ> | aᵢ₋₁, aᵢ ∈ D, i = 2,...,n}
              约定aₙ为栈顶元素，a₁为栈底元素
- **基本操作：**
  - InitStack(&S)        // 初始化栈
  - DestroyStack(&S)     // 销毁栈
  - StackEmpty(S)        // 判断栈是否为空
  - StackLength(S)       // 求栈的长度
  - GetTop(S, &e)        // 取栈顶元素
  - ClearStack(&S)       // 清空栈
  - Push(&S, e)          // 入栈操作
  - Pop(&S, &e)          // 出栈操作
  - StackTraverse(S)     // 遍历栈
**} ADT Stack**

### 3.3.1 栈的类型定义
```c
// 顺序栈类型定义
typedef struct {
    SElemType *base;    // 栈底指针
    SElemType *top;     // 栈顶指针
    int stacksize;      // 当前已分配的存储空间，以元素为单位
} SeqStack;

// 链栈类型定义
typedef struct StackNode {
    SElemType data;              // 数据域
    struct StackNode *next;      // 指针域，指向下一个节点
} StackNode, *LinkStack;
```

### 3.3.2 顺序栈的表示和实现
```c
// 顺序栈初始化
void initSeqStack(SeqStack *s) {
    s->base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!s->base) exit(OVERFLOW);  // 存储分配失败
    s->top = s->base;              // 栈顶指针等于栈底指针
    s->stacksize = STACK_INIT_SIZE; // 设置栈的初始容量
}

// 顺序栈入栈操作
int pushSeqStack(SeqStack *s, ElemType e) {
    // 栈满，追加存储空间
    if (s->top - s->base >= s->stacksize) {
        s->base = (SElemType*)realloc(s->base, (s->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!s->base) return ERROR;  // 存储分配失败
        s->top = s->base + s->stacksize;  // 修改栈顶指针
        s->stacksize += STACKINCREMENT;   // 增加存储容量
    }
    *s->top++ = e;  // 元素e压入栈顶，栈顶指针加1
    return OK;
}

// 顺序栈出栈操作
int popSeqStack(SeqStack *s, ElemType *e) {
    if (s->top == s->base) return ERROR;  // 栈空
    *e = *--s->top;  // 栈顶指针减1，将栈顶元素赋给e
    return OK;
}
```

### 3.3.3 链栈的表示和实现
```c
// 链栈初始化
void initLinkStack(LinkStack *s) {
    *s = NULL;  // 设置栈顶指针为空
}

// 链栈入栈操作
int pushLinkStack(LinkStack *s, ElemType e) {
    LinkStack p = (LinkStack)malloc(sizeof(StackNode));  // 生成新节点
    if (!p) return ERROR;  // 内存分配失败
    p->data = e;           // 将新元素赋值给新节点的数据域
    p->next = *s;          // 将新节点插入栈顶
    *s = p;                // 修改栈顶指针
    return OK;
}

// 链栈出栈操作
int popLinkStack(LinkStack *s, ElemType *e) {
    if (*s == NULL) return ERROR;  // 栈空
    LinkStack p = *s;              // 用p临时保存栈顶元素空间
    *e = (*s)->data;               // 保存栈顶元素
    *s = (*s)->next;               // 修改栈顶指针
    free(p);                       // 释放原栈顶元素空间
    return OK;
}
```

## 3.4 栈与递归

### 3.4.1 采用递归算法解决的问题
- **递归问题类型：**
  - 数学计算问题：阶乘、斐波那契数列、汉诺塔问题
  - 树形结构遍历：二叉树的前序、中序、后序遍历
  - 图的深度优先搜索：迷宫求解、图的连通性判断
  - 分治算法：快速排序、归并排序、二分查找
  - 回溯算法：八皇后问题、数独求解、背包问题

- **递归算法特点：**
  - 问题可以分解为规模更小的相同问题
  - 存在递归终止条件（基础情况）
  - 递归调用最终会收敛到终止条件
  - 每次递归调用都在解决一个子问题

### 3.4.2 递归过程与递归工作栈
- **递归调用过程：**
  - 当函数调用自身时，系统会为每次调用创建一个新的活动记录（栈帧）
  - 活动记录包含局部变量、形式参数、返回地址等信息
  - 新的活动记录被压入系统栈中
  - 当递归终止条件满足时，开始逐层返回，活动记录依次出栈

- **递归工作栈的作用：**
  - 保存每次递归调用的现场信息
  - 确保递归调用能够正确返回到上一层
  - 管理局部变量和参数的作用域
  - 控制程序执行的层次和顺序

### 3.4.3 递归算法的效率分析
- **时间复杂度分析：**
  - 递归算法的时间复杂度通常由递推关系决定
  - 对于简单的线性递归，时间复杂度通常是O(n)
  - 对于分治类递归，如二分查找是O(log n)，归并排序是O(n log n)
  - 对于树形递归，如斐波那契数列是O(2^n)

- **空间复杂度分析：**
  - 递归算法的空间复杂度主要由递归工作栈决定
  - 最坏情况下空间复杂度为O(n)，其中n为递归深度
  - 每次递归调用都需要在栈中保存活动记录
  - 递归深度过大可能导致栈溢出

### 3.4.4 利用栈将递归转换为非递归的方法
```c
// 递归转非递归示例：计算阶乘
// 递归版本
int factorial_recursive(int n) {
    if (n <= 1) return 1;
    return n * factorial_recursive(n - 1);
}

// 非递归版本（使用栈）
int factorial_iterative(int n) {
    if (n <= 1) return 1;
    
    SeqStack S;
    InitStack(&S);
    
    // 将需要计算的数依次入栈
    while (n > 1) {
        Push(&S, n);
        n--;
    }
    
    int result = 1;
    SElemType temp;
    // 依次出栈并相乘
    while (!StackEmpty(S)) {
        Pop(&S, &temp);
        result *= temp;
    }
    
    return result;
}
```

## 3.5 队列的表示和操作的实现

### 3.5.1 队列的类型定义
```c
// 循环队列类型定义
typedef struct {
    QElemType *base;     // 存储空间基址
    int front;           // 头指针
    int rear;            // 尾指针
    int queuesize;       // 当前分配的存储容量
} SqQueue;

// 链队类型定义
typedef struct QNode {
    QElemType data;        // 数据域
    struct QNode *next;    // 指针域
} QNode, *QueuePtr;

typedef struct {
    QueuePtr front;        // 队头指针
    QueuePtr rear;         // 队尾指针
} LinkQueue;
```

### 3.5.2 循环队列——队列的顺序表示和实现
```c
// 循环队列初始化
void initCircularQueue(SqQueue *q) {
    q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    if (!q->base) exit(OVERFLOW);  // 存储分配失败
    q->front = q->rear = 0;        // 头指针和尾指针置为零
    q->queuesize = MAXQSIZE;       // 设置队列容量
}

// 循环队列入队操作
int enqueueCircular(SqQueue *q, QElemType e) {
    if ((q->rear + 1) % q->queuesize == q->front) 
        return ERROR;  // 队列满
    q->base[q->rear] = e;              // 新元素加入队尾
    q->rear = (q->rear + 1) % q->queuesize;  // 队尾指针加1
    return OK;
}

// 循环队列出队操作
int dequeueCircular(SqQueue *q, QElemType *e) {
    if (q->front == q->rear) return ERROR;  // 队列空
    *e = q->base[q->front];                 // 保存队头元素
    q->front = (q->front + 1) % q->queuesize;  // 队头指针加1
    return OK;
}
```

### 3.5.3 链队——队列的链式表示和实现
```c
// 链队初始化
void initLinkQueue(LinkQueue *q) {
    q->front = q->rear = (QueuePtr)malloc(sizeof(QNode));
    if (!q->front) exit(OVERFLOW);  // 存储分配失败
    q->front->next = NULL;          // 头节点指针域置空
}

// 链队入队操作
int enqueueLink(LinkQueue *q, QElemType e) {
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode));
    if (!p) return ERROR;  // 存储分配失败
    p->data = e;           // 设置新节点数据
    p->next = NULL;        // 新节点指针域置空
    q->rear->next = p;     // 将新节点链接到队尾
    q->rear = p;           // 修改队尾指针
    return OK;
}

// 链队出队操作
int dequeueLink(LinkQueue *q, QElemType *e) {
    if (q->front == q->rear) return ERROR;  // 队列空
    QueuePtr p = q->front->next;            // 指向队头元素
    *e = p->data;                           // 保存队头元素值
    q->front->next = p->next;               // 修改头节点指针
    if (q->rear == p) q->rear = q->front;   // 最后一个元素被删去
    free(p);                                // 释放原队头元素空间
    return OK;
}






---
*学习记录于 2025年11月27日 | 下一章：树和二叉树*