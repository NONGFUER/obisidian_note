# 完全二叉树与满二叉树的应用对比

## 完全二叉树（更常见）

**核心特点：**
- 结构灵活，存储友好
- 可用数组高效表示，节省指针空间

**主要应用场景：**
1. **堆数据结构**（二叉堆）
   - 实现优先队列
   - 堆排序算法
   - 操作系统任务调度
   - 贪心算法基础

2. **内存优化场景**
   - 内存受限环境
   - 追求极致性能的应用

## 满二叉树（特定应用）

**核心特点：**
- 绝对平衡，结构规整

**主要应用场景：**
- **哈夫曼编码**（数据压缩算法）
- 特定算法中的平衡结构

## 总结
完全二叉树在实际应用中远比满二叉树常见，因其灵活性和存储效率更适应通用数据结构需求。

## 树与二叉树的转换：左孩子右兄弟法则

**转换规则：**
- **左孩子**：原树中节点的第一个孩子成为二叉树的左孩子
- **右兄弟**：原树中节点的兄弟成为二叉树的右孩子

**转换步骤：**
1. 在原树中，每个节点的第一个孩子作为二叉树的左孩子
2. 同一节点的其他孩子依次作为右孩子链
3. 保持原树的层次关系不变

**优点：**
- 将任意树结构转换为二叉树
- 便于使用二叉树算法处理一般树
- 节省存储空间

## 二叉树的存储方式

### 1. 顺序存储（数组存储）

**适用场景：** 完全二叉树
**存储原理：** 使用数组按层次顺序存储节点

**索引计算规则：**
- 父节点索引 = (子节点索引 - 1) / 2
- 左孩子索引 = 2 * 父节点索引 + 1
- 右孩子索引 = 2 * 父节点索引 + 2

**优点：**
- 节省指针空间
- 内存连续，访问效率高
- 适合完全二叉树结构

**缺点：**
- 不适合非完全二叉树（浪费空间）
- 插入删除操作复杂

**代码示例：**
```c
typedef struct {
    int data[MAX_SIZE];
    int size;
} ArrayBinaryTree;

// 插入节点（按完全二叉树顺序）
void insertArrayNode(ArrayBinaryTree *tree, int value) {
    if (tree->size >= MAX_SIZE) return;
    tree->data[tree->size++] = value;
}
```

### 2. 链式存储

**适用场景：** 所有二叉树类型
**存储原理：** 每个节点包含数据和左右孩子指针

**节点结构：**
```c
typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;
```

**优点：**
- 结构灵活，适合任意二叉树
- 插入删除操作简单
- 不浪费存储空间

**缺点：**
- 需要额外存储指针
- 内存不连续，访问效率稍低

**代码示例：**
```c
// 创建新节点
TreeNode* createNode(int value) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->data = value;
    node->left = node->right = NULL;
    return node;
}
```

## 二叉树的深度优先遍历

### 1. 前序遍历（Pre-order Traversal）

**访问顺序：** 根节点 → 左子树 → 右子树
**应用场景：** 复制树结构、前缀表达式

**递归实现：**
```c
void preOrder(TreeNode* root) {
    if (!root) return;
    printf("%d ", root->data);     // 访问根
    preOrder(root->left);          // 遍历左子树
    preOrder(root->right);         // 遍历右子树
}
```

**非递归实现（使用栈）：**
```c
void preOrderIterative(TreeNode* root) {
    if (!root) return;
    Stack* stack = createStack();
    push(stack, root);
    
    while (!isEmpty(stack)) {
        TreeNode* node = pop(stack);
        printf("%d ", node->data);
        if (node->right) push(stack, node->right);  // 右孩子先入栈
        if (node->left) push(stack, node->left);    // 左孩子后入栈
    }
}
```

### 2. 中序遍历（In-order Traversal）

**访问顺序：** 左子树 → 根节点 → 右子树
**应用场景：** 二叉搜索树的有序输出、中缀表达式

**递归实现：**
```c
void inOrder(TreeNode* root) {
    if (!root) return;
    inOrder(root->left);           // 遍历左子树
    printf("%d ", root->data);     // 访问根
    inOrder(root->right);          // 遍历右子树
}
```

**非递归实现（使用栈）：**
```c
void inOrderIterative(TreeNode* root) {
    Stack* stack = createStack();
    TreeNode* curr = root;
    
    while (curr || !isEmpty(stack)) {
        while (curr) {              // 一直向左走到底
            push(stack, curr);
            curr = curr->left;
        }
        curr = pop(stack);          // 回溯到父节点
        printf("%d ", curr->data);
        curr = curr->right;         // 转向右子树
    }
}
```

### 3. 后序遍历（Post-order Traversal）

**访问顺序：** 左子树 → 右子树 → 根节点
**应用场景：** 释放树内存、后缀表达式、计算目录大小

**递归实现：**
```c
void postOrder(TreeNode* root) {
    if (!root) return;
    postOrder(root->left);          // 遍历左子树
    postOrder(root->right);         // 遍历右子树
    printf("%d ", root->data);      // 访问根
}
```

**非递归实现（使用双栈）：**
```c
void postOrderIterative(TreeNode* root) {
    if (!root) return;
    Stack* stack1 = createStack();
    Stack* stack2 = createStack();
    push(stack1, root);
    
    while (!isEmpty(stack1)) {
        TreeNode* node = pop(stack1);
        push(stack2, node);         // 结果栈
        if (node->left) push(stack1, node->left);
        if (node->right) push(stack1, node->right);
    }
    
    while (!isEmpty(stack2)) {
        printf("%d ", pop(stack2)->data);
    }
}
```

## 遍历方法对比

| 遍历方式 | 访问顺序 | 应用场景 | 时间复杂度 | 空间复杂度 |
|---------|---------|---------|-----------|-----------|
| 前序遍历 | 根→左→右 | 复制树、前缀表达式 | O(n) | O(h) |
| 中序遍历 | 左→根→右 | 二叉搜索树排序 | O(n) | O(h) |
| 后序遍历 | 左→右→根 | 释放内存、后缀表达式 | O(n) | O(h) |

**说明：**
- n: 节点总数
- h: 树的高度（递归深度）

## 实践建议

### 存储方式选择
- **顺序存储**：适用于完全二叉树、堆结构
- **链式存储**：适用于任意二叉树、需要频繁插入删除的场景

### 遍历方法选择
- **前序遍历**：需要先处理根节点的场景
- **中序遍历**：二叉搜索树的有序输出
- **后序遍历**：需要先处理子节点的场景

### 递归与非递归
- **递归实现**：代码简洁，易于理解
- **非递归实现**：避免栈溢出，适合深度较大的树